


PermissionController = function() {
   // list all ip addresses that should be blocked
	this.blacklist = [];
	// list all ip addresses that should be allowed
	this.whitelist = [];
	
	// watch the config files for black- and whitelist
	// if a file changes update the list at runtime - no restart required
	try {
		fs.watchFile('./conf/blacklist', function(c,p) { updatePermissions(); });
		fs.watchFile('./conf/whitelist', function(c,p) { updatePermissions(); });
	} catch (err){
		sys.log(err);
	}
};

/*
Get the collection 'collection' in the this.db.
Call the callback function with either the data/collection or the error returned by the 
db-qeuery as argument. 
@param collection: The name of the collection that should be accessed
@param callback: The callback function to call after the db-query is finished
*/
DBHandler.prototype.getCollection = function(collection, callback) {
   this.db.collection(collection, function(error, res_collection) {
    if(error) {
     callback(error);
    } else {
     callback(null, res_collection);
    }
   });
};



// read the allowed and blocked ip addresses from the config files
// triggered once when server starts & and everytime the config changes
PermissionController.prototype.updatePermissions = function() {
	sys.log("Updating permissions");
	try {
		blacklist = fs.readFileSync('./conf/blacklist', encoding='utf8').split('\n')
						.filter(function(ip) { return ip.length });
		whitelist = fs.readFileSync('./conf/whitelist', encoding='utf8').split('\n')
						.filter(function(ip) { return ip.length });
	} catch (err) {
		sys.log(err);
	}
}

// check if the ip is blacklisted/banned
// @param ip: the ip address to check
function isBanned(ip){
	for (i in blacklist) {
		if (blacklist[i] == ip) {
			return true;
		}
	} 
	return false;
}

// if the config file is not empty check if the ip is whitelisted/allowed
// @param ip: the ip address to check
function isAllowed(ip) {
	if (whitelist.length == 0) return true;
	for (i in whitelist) {
		if (whitelist[i] == ip) {
			return true;
		}
	}
	return false;
}

// when invalid client deny the response
function deny(response, msg) {
  response.writeHead(403);
  response.write(msg);
  response.end();
}